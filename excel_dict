' Module: DataProcessingModule

Option Explicit

Public dictHeaders As Object
Public arrNewHeaders As Variant
Public dictMappedHeaders As Object

Sub ProcessData()
    ' Initialize variables
    Set dictHeaders = CreateObject("Scripting.Dictionary")
    Set dictMappedHeaders = CreateObject("Scripting.Dictionary")
    arrNewHeaders = Array("device name", "console server", "console port", "monitor switch", "monitor port", "oob mgmt port", "upstream device", "upstream port")
    
    ' Get the selected range
    Dim rng As Range
    On Error Resume Next
    Set rng = Selection
    On Error GoTo 0
    
    If rng Is Nothing Then
        MsgBox "Please select a range first, then click the button again.", vbExclamation
        Exit Sub
    End If
    
    ' Process the data
    If Not ReadHeaders(rng) Then
        MsgBox "There was an issue reading the headers. Please check your data and try again.", vbExclamation
        Exit Sub
    End If
    
    ' Display the headers that were read
    DisplayHeaders "Headers read:", dictHeaders
    
    ' Show the header mapping form
    ufHeaderMapping.Show
    
    ' Check if header mapping was successful
    If dictMappedHeaders.Count = 0 Then
        MsgBox "Header mapping was not completed. Process will exit.", vbExclamation
        Exit Sub
    End If
    
    ' Display the mapped headers
    DisplayHeaders "Mapped Headers:", dictMappedHeaders
    
    Call ProcessColumns(rng)
    
    MsgBox "Data processing complete!", vbInformation
End Sub

Private Function ReadHeaders(rng As Range) As Boolean
    Dim cell As Range
    Dim duplicateHeaders As Object
    Set duplicateHeaders = CreateObject("Scripting.Dictionary")
    
    For Each cell In rng.Rows(1).Cells
        If Not IsEmpty(cell.Value) Then
            If dictHeaders.Exists(cell.Value) Then
                ' Found a duplicate header
                If Not duplicateHeaders.Exists(cell.Value) Then
                    duplicateHeaders.Add cell.Value, New Collection
                End If
                duplicateHeaders(cell.Value).Add cell.Column
            Else
                dictHeaders.Add cell.Value, cell.Column
            End If
        End If
    Next cell
    
    ' Handle duplicate headers
    If duplicateHeaders.Count > 0 Then
        Dim header As Variant
        For Each header In duplicateHeaders.Keys
            Dim chosenColumn As Long
            chosenColumn = PromptForHeaderChoice(CStr(header), duplicateHeaders(header))
            If chosenColumn = 0 Then
                ' User cancelled
                ReadHeaders = False
                Exit Function
            End If
            
            ' Update dictHeaders with the chosen column
            dictHeaders(header) = chosenColumn
            
            ' If this was a "Device name" header, map the other one to "upstream device"
            If LCase(header) = "device name" Then
                Dim otherColumn As Variant
                For Each otherColumn In duplicateHeaders(header)
                    If CLng(otherColumn) <> chosenColumn Then
                        dictHeaders.Add header & " (upstream)", CLng(otherColumn)
                        Exit For
                    End If
                Next otherColumn
            End If
        Next header
    End If
    
    ReadHeaders = True
End Function

Private Function PromptForHeaderChoice(header As String, columns As Collection) As Long
    Dim msg As String
    Dim i As Integer
    Dim response As Integer
    
    msg = "Duplicate header '" & header & "' found in columns: " & vbNewLine
    For i = 1 To columns.Count
        msg = msg & "  " & i & ". Column " & columns(i) & vbNewLine
    Next i
    msg = msg & "Which column would you like to use for '" & header & "'?"
    
    response = Application.InputBox(msg, "Choose Column", Type:=1)
    
    If response = 0 Then
        ' User cancelled
        PromptForHeaderChoice = 0
    ElseIf response > 0 And response <= columns.Count Then
        PromptForHeaderChoice = CLng(columns(response))
    Else
        MsgBox "Invalid selection. Please try again.", vbExclamation
        PromptForHeaderChoice = PromptForHeaderChoice(header, columns)  ' Recursive call for retry
    End If
End Function

Private Sub ProcessColumns(rng As Range)
    Dim deviceNameCol As Long
    Dim deviceNames As Object
    Dim mainDict As Object
    Dim row As Range
    Dim deviceName As String
    Dim i As Long
    Dim attr As Variant
    
    ' Find the column number for "device name"
    For Each attr In dictMappedHeaders
        If dictMappedHeaders(attr) = "device name" Then
            deviceNameCol = dictHeaders(attr)
            Exit For
        End If
    Next attr
    
    If deviceNameCol = 0 Then
        MsgBox "Device Name column not found. Please ensure it's mapped correctly.", vbExclamation
        Exit Sub
    End If
    
    ' Create a dictionary to store unique device names
    Set deviceNames = CreateObject("Scripting.Dictionary")
    Set mainDict = CreateObject("Scripting.Dictionary")
    
    ' Process rows
    For i = 2 To rng.Rows.Count ' Assuming first row is header
        deviceName = rng.Cells(i, deviceNameCol).Value
        If Not deviceNames.Exists(deviceName) Then
            deviceNames.Add deviceName, i
            
            Dim subDict As Object
            Set subDict = CreateObject("Scripting.Dictionary")
            
            ' Populate sub-dictionary with attributes
            For Each attr In dictMappedHeaders.Keys
                subDict.Add dictMappedHeaders(attr), rng.Cells(i, dictHeaders(attr)).Value
            Next attr
            
            ' Add to main dictionary
            mainDict.Add deviceName, subDict
        Else
            ' Handle duplicate device name
            Select Case HandleDuplicateDeviceName(deviceName, i, deviceNames(deviceName))
                Case vbYes ' Keep first occurrence
                    ' Do nothing, keep existing entry
                Case vbNo ' Append unique identifier
                    Dim newDeviceName As String
                    newDeviceName = AppendUniqueIdentifier(deviceName, i)
                    deviceNames.Add newDeviceName, i
                    
                    Set subDict = CreateObject("Scripting.Dictionary")
                    For Each attr In dictMappedHeaders.Keys
                        subDict.Add dictMappedHeaders(attr), rng.Cells(i, dictHeaders(attr)).Value
                    Next attr
                    mainDict.Add newDeviceName, subDict
                Case vbCancel ' Cancel operation
                    MsgBox "Operation cancelled. Please correct duplicate device names and try again.", vbExclamation
                    Exit Sub
            End Select
        End If
    Next i
    
    ' Print dictionary contents
    Call PrintDictionaryContents(mainDict)
End Sub

Private Function HandleDuplicateDeviceName(deviceName As String, newRow As Long, existingRow As Long) As VbMsgBoxResult
    HandleDuplicateDeviceName = MsgBox("Duplicate device name '" & deviceName & "' found in rows " & existingRow & " and " & newRow & "." & vbNewLine & _
                      "How would you like to proceed?" & vbNewLine & vbNewLine & _
                      "Yes - Keep first occurrence (row " & existingRow & ")" & vbNewLine & _
                      "No - Append unique identifier to second occurrence (row " & newRow & ")" & vbNewLine & _
                      "Cancel - Stop processing and allow manual correction", _
                      vbYesNoCancel + vbQuestion, "Duplicate Device Name")
End Function

Private Function AppendUniqueIdentifier(deviceName As String, rowNum As Long) As String
    AppendUniqueIdentifier = deviceName & "_" & rowNum
End Function

Private Sub PrintDictionaryContents(dict As Object)
    Dim ws As Worksheet
    Dim deviceName As Variant
    Dim attr As Variant
    Dim rowNum As Long
    Dim colNum As Integer
    
    ' Add a new worksheet to display results
    Set ws = ThisWorkbook.Worksheets.Add
    ws.Name = "Dictionary Contents " & Format(Now, "yyyymmdd_hhmmss")
    
    ' Set up headers
    ws.Cells(1, 1).Value = "Device Name"
    rowNum = 2
    
    ' Print dictionary contents
    For Each deviceName In dict.Keys
        ws.Cells(rowNum, 1).Value = deviceName
        colNum = 2
        
        For Each attr In dict(deviceName).Keys
            ' If this is the first device, add the attribute name as a header
            If rowNum = 2 Then
                ws.Cells(1, colNum).Value = attr
            End If
            
            ws.Cells(rowNum, colNum).Value = dict(deviceName)(attr)
            colNum = colNum + 1
        Next attr
        
        rowNum = rowNum + 1
    Next deviceName
    
    ' Auto-fit columns for better readability
    ws.UsedRange.Columns.AutoFit
    
    ' Inform user
    MsgBox "Dictionary contents have been printed to the new worksheet '" & ws.Name & "'", vbInformation
End Sub

Private Sub DisplayHeaders(title As String, dict As Object)
    Dim key As Variant
    Dim info As String
    info = title & vbNewLine
    For Each key In dict.Keys
        info = info & key & ": " & dict(key) & vbNewLine
    Next key
    MsgBox info, vbInformation, title
End Sub

' UserForm: ufHeaderMapping

Private Sub UserForm_Initialize()
    Me.Caption = "Map Headers"
    Me.Width = 400
    Me.Height = 300 + (DataProcessingModule.dictHeaders.Count * 30)
    
    ' Add instructions label
    Dim lblInstructions As MSForms.Label
    Set lblInstructions = Me.Controls.Add("Forms.Label.1", "lblInstructions")
    With lblInstructions
        .Caption = "Map original headers to new headers:"
        .Left = 10
        .Top = 10
        .Width = 380
    End With
    
    ' Add controls for each header
    Dim i As Integer
    Dim header As Variant
    i = 0
    For Each header In DataProcessingModule.dictHeaders.Keys
        ' Add label for original header
        Dim lblOrigHeader As MSForms.Label
        Set lblOrigHeader = Me.Controls.Add("Forms.Label.1", "lblOrigHeader" & i)
        With lblOrigHeader
            .Caption = header
            .Left = 10
            .Top = 40 + (i * 30)
            .Width = 150
        End With
        
        ' Add dropdown for new header
        Dim cboNewHeader As MSForms.ComboBox
        Set cboNewHeader = Me.Controls.Add("Forms.ComboBox.1", "cboNewHeader" & i)
        With cboNewHeader
            .Left = 170
            .Top = 40 + (i * 30)
            .Width = 200
            
            ' Populate dropdown with new header options
            Dim j As Integer
            For j = 0 To UBound(DataProcessingModule.arrNewHeaders)
                .AddItem DataProcessingModule.arrNewHeaders(j)
            Next j
            
            ' Set default value if it's a match or for "upstream device"
            If LCase(header) = "device name (upstream)" Then
                .Value = "upstream device"
            ElseIf IsInArray(LCase(header), DataProcessingModule.arrNewHeaders) Then
                .Value = LCase(header)
            End If
        End With
        
        i = i + 1
    Next header
    
    ' Add OK and Cancel buttons
    Dim btnOK As MSForms.CommandButton
    Set btnOK = Me.Controls.Add("Forms.CommandButton.1", "btnOK")
    With btnOK
        .Caption = "OK"
        .Left = 170
        .Top = Me.InsideHeight - 40
        .Width = 80
    End With
    
    Dim btnCancel As MSForms.CommandButton
    Set btnCancel = Me.Controls.Add("Forms.CommandButton.1", "btnCancel")
    With btnCancel
        .Caption = "Cancel"
        .Left = 260
        .Top = Me.InsideHeight - 40
        .Width = 80
    End With
End Sub

Private Sub btnOK_Click()
    Call ProcessHeaderMapping
    Me.Hide
End Sub

Private Sub btnCancel_Click()
    Me.Hide
End Sub

Private Sub ProcessHeaderMapping()
    Dim i As Integer
    Dim originalHeader As Variant
    i = 0
    For Each originalHeader In DataProcessingModule.dictHeaders.Keys
        Dim newHeader As String
        newHeader = Me.Controls("cboNewHeader" & i).Value
        If newHeader <> "" Then
            DataProcessingModule.dictMappedHeaders.Add originalHeader, newHeader
        End If
        i = i + 1
    Next originalHeader
End Sub

Private Function IsInArray(stringToBeFound As String, arr As Variant) As Boolean
    IsInArray = (UBound(Filter(arr, stringToBeFound)) > -1)
End Function
