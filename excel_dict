' Main Module: DataProcessingModule

Option Explicit

' Global variables
Private dictHeaders As Object
Private arrNewHeaders As Variant
Private dictMappedHeaders As Object

Sub ProcessData()
    ' This is the main subroutine that will be triggered by the button
    
    ' Initialize variables
    Set dictHeaders = CreateObject("Scripting.Dictionary")
    Set dictMappedHeaders = CreateObject("Scripting.Dictionary")
    arrNewHeaders = Array("device name", "console server", "console port", "monitor switch", "monitor port", "oob mgmt port", "upstream device", "upstream port")
    
    ' Get the selected range
    Dim rng As Range
    On Error Resume Next
    Set rng = Selection
    On Error GoTo 0
    
    If rng Is Nothing Then
        MsgBox "Please select a range first, then click the button again.", vbExclamation
        Exit Sub
    End If
    
    ' Process the data
    If Not ReadHeaders(rng) Then
        MsgBox "There was an issue reading the headers. Please check your data and try again.", vbExclamation
        Exit Sub
    End If
    
    ' Display the headers that were read
    Dim key As Variant
    Dim headerInfo As String
    headerInfo = "Headers read:" & vbNewLine
    For Each key In dictHeaders.Keys
        headerInfo = headerInfo & key & ": Column " & dictHeaders(key) & vbNewLine
    Next key
    MsgBox headerInfo, vbInformation, "Headers Read"
    
    Call PromptForHeaderMapping
    
    ' Check if header mapping was successful
    If dictMappedHeaders.Count = 0 Then
        MsgBox "Header mapping was not completed. Process will exit.", vbExclamation
        Exit Sub
    End If
    
    ' Display the mapped headers
    Dim mappedHeaderInfo As String
    mappedHeaderInfo = "Mapped Headers:" & vbNewLine
    For Each key In dictMappedHeaders.Keys
        mappedHeaderInfo = mappedHeaderInfo & key & " -> " & dictMappedHeaders(key) & vbNewLine
    Next key
    MsgBox mappedHeaderInfo, vbInformation, "Mapped Headers"
    
    Call ProcessColumns(rng)
    
    MsgBox "Data processing complete!", vbInformation
End Sub

Private Function ReadHeaders(rng As Range) As Boolean
    ' Read the headers from the first row of the selection
    Dim cell As Range
    Dim duplicateHeaders As Object
    Set duplicateHeaders = CreateObject("Scripting.Dictionary")
    
    For Each cell In rng.Rows(1).Cells
        If Not IsEmpty(cell.Value) Then
            If dictHeaders.Exists(cell.Value) Then
                ' Found a duplicate header
                If Not duplicateHeaders.Exists(cell.Value) Then
                    duplicateHeaders.Add cell.Value, cell.Value
                End If
                ' Store column numbers in dictHeaders with a prefix
                dictHeaders.Add "dup_" & cell.Value & "_" & cell.Column, cell.Column
            Else
                dictHeaders.Add cell.Value, cell.Column
            End If
        End If
    Next cell
    
    ' Handle duplicate headers
    If duplicateHeaders.Count > 0 Then
        Dim header As Variant
        For Each header In duplicateHeaders.Keys
            Dim columns As New Collection
            Dim key As Variant
            For Each key In dictHeaders.Keys
                If Left(key, 4 + Len(header)) = "dup_" & header & "_" Then
                    columns.Add dictHeaders(key)
                End If
            Next key
            
            If columns.Count > 0 Then
                columns.Add dictHeaders(header) ' Add the original column too
                
                Dim chosenColumn As Long
                chosenColumn = PromptForHeaderChoice(CStr(header), columns)
                If chosenColumn = 0 Then
                    ' User cancelled
                    ReadHeaders = False
                    Exit Function
                End If
                
                ' Update dictHeaders with the chosen column
                dictHeaders(header) = chosenColumn
                
                ' If this was a "Device name" header, map the other one to "upstream device"
                If LCase(header) = "device name" Then
                    Dim otherColumn As Variant
                    For Each otherColumn In columns
                        If CLng(otherColumn) <> chosenColumn Then
                            dictHeaders.Add header & " (upstream)", CLng(otherColumn)
                            Exit For
                        End If
                    Next otherColumn
                End If
                
                ' Remove duplicate entries
                Dim keysToRemove As New Collection
                For Each key In dictHeaders.Keys
                    If Left(key, 4 + Len(header)) = "dup_" & header & "_" Then
                        keysToRemove.Add key
                    End If
                Next key
                
                ' Remove the keys
                Dim keyToRemove As Variant
                For Each keyToRemove In keysToRemove
                    dictHeaders.Remove CStr(keyToRemove)
                Next keyToRemove
            End If
        Next header
    End If
    
    ReadHeaders = True
End Function

Private Function PromptForHeaderChoice(header As String, columns As Collection) As Long
    Dim msg As String
    Dim i As Integer
    Dim response As Integer
    
    msg = "Duplicate header '" & header & "' found in columns: " & vbNewLine
    For i = 1 To columns.Count
        msg = msg & "  " & i & ". Column " & columns(i) & vbNewLine
    Next i
    msg = msg & "Which column would you like to use for '" & header & "'?"
    
    response = Application.InputBox(msg, "Choose Column", Type:=1)
    
    If response = 0 Then
        ' User cancelled
        PromptForHeaderChoice = 0
    ElseIf response > 0 And response <= columns.Count Then
        PromptForHeaderChoice = CLng(columns(response))
    Else
        MsgBox "Invalid selection. Please try again.", vbExclamation
        PromptForHeaderChoice = PromptForHeaderChoice(header, columns)  ' Recursive call for retry
    End If
End Function

Private Sub PromptForHeaderMapping()
    ' Clear existing controls
    Dim ctrl As Control
    For Each ctrl In ufHeaderMapping.Controls
        ufHeaderMapping.Controls.Remove ctrl.Name
    Next ctrl
    
    ' Set form properties
    With ufHeaderMapping
        .Caption = "Map Headers"
        .Width = 400
        .Height = 300 + (dictHeaders.Count * 30)
        
        ' Add instructions label
        Dim lblInstructions As MSForms.Label
        Set lblInstructions = .Controls.Add("Forms.Label.1", "lblInstructions")
        With lblInstructions
            .Caption = "Map original headers to new headers:"
            .Left = 10
            .Top = 10
            .Width = 380
        End With
        
        ' Add controls for each header
        Dim i As Integer
        i = 0
        Dim header As Variant
        For Each header In dictHeaders.Keys
            ' Add label for original header
            Dim lblOrigHeader As MSForms.Label
            Set lblOrigHeader = .Controls.Add("Forms.Label.1", "lblOrigHeader" & i)
            With lblOrigHeader
                .Caption = header
                .Left = 10
                .Top = 40 + (i * 30)
                .Width = 150
            End With
            
            ' Add dropdown for new header
            Dim cboNewHeader As MSForms.ComboBox
            Set cboNewHeader = .Controls.Add("Forms.ComboBox.1", "cboNewHeader" & i)
            With cboNewHeader
                .Left = 170
                .Top = 40 + (i * 30)
                .Width = 200
                
                ' Populate dropdown with new header options
                Dim j As Integer
                For j = 0 To UBound(arrNewHeaders)
                    .AddItem arrNewHeaders(j)
                Next j
                
                ' Set default value if it's a match or for "upstream device"
                If LCase(header) = "device name (upstream)" Then
                    .Value = "upstream device"
                ElseIf IsInArray(LCase(header), arrNewHeaders) Then
                    .Value = LCase(header)
                End If
            End With
            
            i = i + 1
        Next header
        
        ' Add OK and Cancel buttons
        Dim btnOK As MSForms.CommandButton
        Set btnOK = .Controls.Add("Forms.CommandButton.1", "btnOK")
        With btnOK
            .Caption = "OK"
            .Left = 170
            .Top = .Parent.InsideHeight - 40
            .Width = 80
        End With
        
        Dim btnCancel As MSForms.CommandButton
        Set btnCancel = .Controls.Add("Forms.CommandButton.1", "btnCancel")
        With btnCancel
            .Caption = "Cancel"
            .Left = 260
            .Top = .Parent.InsideHeight - 40
            .Width = 80
        End With
    End With
    
    ' Show the form
    ufHeaderMapping.Show
End Sub

Private Sub ProcessColumns(rng As Range)
    Dim deviceNameCol As Long
    Dim deviceNames As Object
    Dim mainDict As Object
    Dim row As Range
    Dim deviceName As String
    Dim i As Long
    Dim attr As Variant
    
    ' Find the column number for "device name"
    For Each attr In dictMappedHeaders
        If dictMappedHeaders(attr) = "device name" Then
            deviceNameCol = dictHeaders(attr)
            Exit For
        End If
    Next attr
    
    If deviceNameCol = 0 Then
        MsgBox "Device Name column not found. Please ensure it's mapped correctly.", vbExclamation
        Exit Sub
    End If
    
    ' Create a dictionary to store unique device names
    Set deviceNames = CreateObject("Scripting.Dictionary")
    
    ' Scan for duplicate device names
    For i = 2 To rng.Rows.Count ' Assuming first row is header
        deviceName = rng.Cells(i, deviceNameCol).Value
        If Not deviceNames.Exists(deviceName) Then
            deviceNames.Add deviceName, i
        Else
            ' Handle duplicate device name
            Select Case HandleDuplicateDeviceName(deviceName, i, deviceNames(deviceName))
                Case 1 ' Keep first occurrence
                    ' Do nothing, keep existing entry
                Case 2 ' Append unique identifier
                    deviceName = AppendUniqueIdentifier(deviceName, i)
                    deviceNames.Add deviceName, i
                Case 3 ' Cancel operation
                    MsgBox "Operation cancelled. Please correct duplicate device names and try again.", vbExclamation
                    Exit Sub
            End Select
        End If
    Next i
    
    ' Create main dictionary
    Set mainDict = CreateObject("Scripting.Dictionary")
    
    ' Populate main dictionary
    For Each deviceName In deviceNames.Keys
        Dim subDict As Object
        Set subDict = CreateObject("Scripting.Dictionary")
        
        ' Get the row for this device
        Set row = rng.Rows(deviceNames(deviceName))
        
        ' Populate sub-dictionary with attributes
        For Each attr In dictMappedHeaders.Keys
            subDict.Add dictMappedHeaders(attr), row.Cells(1, dictHeaders(attr)).Value
        Next attr
        
        ' Add to main dictionary
        mainDict.Add deviceName, subDict
    Next deviceName
    
    ' Print dictionary contents
    Call PrintDictionaryContents(mainDict)
End Sub

Private Function HandleDuplicateDeviceName(deviceName As String, newRow As Long, existingRow As Long) As Integer
    Dim response As VbMsgBoxResult
    response = MsgBox("Duplicate device name '" & deviceName & "' found in rows " & existingRow & " and " & newRow & "." & vbNewLine & _
                      "How would you like to proceed?" & vbNewLine & vbNewLine & _
                      "Yes - Keep first occurrence (row " & existingRow & ")" & vbNewLine & _
                      "No - Append unique identifier to second occurrence (row " & newRow & ")" & vbNewLine & _
                      "Cancel - Stop processing and allow manual correction", _
                      vbYesNoCancel + vbQuestion, "Duplicate Device Name")
    HandleDuplicateDeviceName = response
End Function

Private Function AppendUniqueIdentifier(deviceName As String, rowNum As Long) As String
    AppendUniqueIdentifier = deviceName & "_" & rowNum
End Function

Private Sub PrintDictionaryContents(dict As Object)
    Dim ws As Worksheet
    Dim deviceName As Variant
    Dim attr As Variant
    Dim rowNum As Long
    
    ' Add a new worksheet to display results
    Set ws = ThisWorkbook.Worksheets.Add
    ws.Name = "Dictionary Contents " & Format(Now, "yyyymmdd_hhmmss")
    
    ' Set up headers
    ws.Cells(1, 1).Value = "Device Name"
    rowNum = 2
    
    ' Print dictionary contents
    For Each deviceName In dict.Keys
        ws.Cells(rowNum, 1).Value = deviceName
        
        Dim colNum As Integer
        colNum = 2
        
        For Each attr In dict(deviceName).Keys
            ' If this is the first device, add the attribute name as a header
            If rowNum = 2 Then
                ws.Cells(1, colNum).Value = attr
            End If
            
            ws.Cells(rowNum, colNum).Value = dict(deviceName)(attr)
            colNum = colNum + 1
        Next attr
        
        rowNum = rowNum + 1
    Next deviceName
    
    ' Auto-fit columns for better readability
    ws.UsedRange.Columns.AutoFit
    
    ' Inform user
    MsgBox "Dictionary contents have been printed to the new worksheet '" & ws.Name & "'", vbInformation
End Sub

Private Function IsInArray(stringToBeFound As String, arr As Variant) As Boolean
    IsInArray = (UBound(Filter(arr, stringToBeFound)) > -1)
End Function

' UserForm Code: ufHeaderMapping

Private Sub btnOK_Click()
    Call ProcessHeaderMapping
    Me.Hide
End Sub

Private Sub btnCancel_Click()
    Me.Hide
End Sub

Private Sub ProcessHeaderMapping()
    Dim i As Integer
    Dim originalHeader As Variant
    i = 0
    For Each originalHeader In DataProcessingModule.dictHeaders.Keys
        Dim newHeader As String
        newHeader = Me.Controls("cboNewHeader" & i).Value
        If newHeader <> "" Then
            DataProcessingModule.dictMappedHeaders.Add originalHeader, newHeader
        End If
        i = i + 1
    Next originalHeader
End Sub
